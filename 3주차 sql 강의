!!!Join 사용 : 여러 테이블에 흩어져 있는 정보(테이블)를 하나로 연결
여기서부터 실전 데이터분석이라 봐도 무방!!

- Left Join : 왼쪽에 있는 테이블을 기준으로 join을 진행
select * from users u(users 데이터를 모두 읽는데)
left join point_users pu(point_users 테이블을 left join해서 읽을거야)
on u.user_id = pu.user_id(left join은 user_id 항목을 기준으로 진행할거고)

- Inner Join : 두 테이블을 붙이긴 하는데 on에 들어간 필드 값이 존재하는 애들만 표현함(교집합)

!! 쿼리 실행 순서
select * from enrolleds e
inner join courses c
on e.course_id = c.course_id; 라는 쿼리는
from(테이블 데이터 불러오고) -> join(다른 테이블과 join을 진행한 다음) -> select(모아진 데이터를 출력함)

### Join과 다른 문법 함께 사용하기

## 1. checkins 테이블에 courses 테이블 연결해서 통계치 내보내기
select * from checkins ci;
select * from courses co;
#course_id가 겹치니 이걸로 join 가능

select * from checkins ci
inner join courses co
on ci.course_id = co.course_id;
#성공적으로 join됨

## 네이버 메일을 쓰는 주문 건들의 성씨별 주문 건수 확인하기
select * from orders o;
select * from users u;
#user_id와 email이 겹침
select name, count(*) from orders o
inner join users u
on o.user_id = u.user_id
where o.email like '%@naver.com'
group by u.name;
# 네이버 메일을 쓰는 주문 건들의 성씨별 주문 건수 확인 완료.

!!!group by는 두 개 이상의 조건을 ,로 걸 수 있음. 예시) 각 강좌의(강좌별) week 별 오늘의 다짐 수 세기
!!!order by도 ,로 두 개 이상의 정렬 기준을 걸 수 있음. order by 첫 번째 정렬 기준, 두 번째 정렬 기준... 그리고 각 기준마다 오름차순/내림차순 설정 가능

## 4. 웹개발, 앱개발 종합반의 week 별 체크인 수 세기
select * from checkins c;
select * from courses c;
# 확인 완료
select co.course_id, co.title, ci.week, count(*) from checkins ci
inner join courses co
on ci.course_id = co.course_id
group by ci.week, co.course_id
order by title, week;
# 확인 완료

!!!세 개 이상의 테이블에도 join을 엮을 수 있음.
# 이 중 8월 1일 이후에 구매한 고객들만 구별하기! orders를 또 붙여야 함
select co.course_id, co.title, ci.week, count(*) from checkins ci
inner join courses co
on ci.course_id = co.course_id
inner join orders o
on ci.user_id = o.user_id
where o.updated_at >= '2020-08-01'
group by ci.week, co.course_id
order by co.course_id, ci.week;
#확인 완료

!! null인 데이터를 찾을 때는 필드명 = null이 아니라 필드명 is null로 찾아야 함

