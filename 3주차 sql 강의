!!!Join 사용 : 여러 테이블에 흩어져 있는 정보(테이블)를 하나로 연결
여기서부터 실전 데이터분석이라 봐도 무방!!

- Left Join : 왼쪽에 있는 테이블을 기준으로 join을 진행
select * from users u(users 데이터를 모두 읽는데)
left join point_users pu(point_users 테이블을 left join해서 읽을거야)
on u.user_id = pu.user_id(left join은 user_id 항목을 기준으로 진행할거고)

- Inner Join : 두 테이블을 붙이긴 하는데 on에 들어간 필드 값이 존재하는 애들만 표현함(교집합)

!! 쿼리 실행 순서
select * from enrolleds e
inner join courses c
on e.course_id = c.course_id; 라는 쿼리는
from(테이블 데이터 불러오고) -> join(다른 테이블과 join을 진행한 다음) -> select(모아진 데이터를 출력함)

### Join과 다른 문법 함께 사용하기

## 1. checkins 테이블에 courses 테이블 연결해서 통계치 내보내기
select * from checkins ci;
select * from courses co;
#course_id가 겹치니 이걸로 join 가능

select * from checkins ci
inner join courses co
on ci.course_id = co.course_id;
#성공적으로 join됨

## 네이버 메일을 쓰는 주문 건들의 성씨별 주문 건수 확인하기
select * from orders o;
select * from users u;
#user_id와 email이 겹침
select name, count(*) from orders o
inner join users u
on o.user_id = u.user_id
where o.email like '%@naver.com'
group by u.name;
# 네이버 메일을 쓰는 주문 건들의 성씨별 주문 건수 확인 완료.

!!!group by는 두 개 이상의 조건을 ,로 걸 수 있음. 예시) 각 강좌의(강좌별) week 별 오늘의 다짐 수 세기
!!!order by도 ,로 두 개 이상의 정렬 기준을 걸 수 있음. order by 첫 번째 정렬 기준, 두 번째 정렬 기준... 그리고 각 기준마다 오름차순/내림차순 설정 가능

## 4. 웹개발, 앱개발 종합반의 week 별 체크인 수 세기
select * from checkins c;
select * from courses c;
# 확인 완료
select co.course_id, co.title, ci.week, count(*) from checkins ci
inner join courses co
on ci.course_id = co.course_id
group by ci.week, co.course_id
order by title, week;
# 확인 완료

!!!세 개 이상의 테이블에도 join을 엮을 수 있음.
# 이 중 8월 1일 이후에 구매한 고객들만 구별하기! orders를 또 붙여야 함
select co.course_id, co.title, ci.week, count(*) from checkins ci
inner join courses co
on ci.course_id = co.course_id
inner join orders o
on ci.user_id = o.user_id
where o.updated_at >= '2020-08-01'
group by ci.week, co.course_id
order by co.course_id, ci.week;
#확인 완료

!! null인 데이터를 찾을 때는 필드명 = null이 아니라 필드명 is null로 찾아야 함
!!!!! count는 null을 세지 않음! 그래서 null이 있는 데이터와 없는 데이터의 수를 요령껏 별칭 붙여서 따로 둘 수 있음
## 1. 7월 10일~19일에 가입한 고객 중 포인트 가진 고객의 수, 전체 수, 비율 보기
select count(pu.point) as pnt_user_cnt, count(*) as tot_user_cnt, round(count(pu.point)/count(*),2) as ratio from users u
left join point_users pu
on u.user_id = pu.user_id
where u.created_at BETWEEN '2020-07-10' and '2020-07-20' 

!!!Union 두 개의 테이블을 이어서 볼 때 사용
# 예시)7월 통계 데이터와 8월 통계 데이터를 이어서 보기
# 아래는 8월 주차별 checkin 수 데이터
select c1.title, c2.week, count(*) as cnt from courses c1
inner join checkins c2 on c1.course_id = c2.course_id
inner join orders o on c2.user_id = o.user_id
where o.created_at >= '2020-08-01'
group by c1.title, c2.week
order by c1.title, c2.week;
# 얘는 7월 주차별
select c1.title, c2.week, count(*) as cnt from courses c1
inner join checkins c2 on c1.course_id = c2.course_id
inner join orders o on c2.user_id = o.user_id
where o.created_at < '2020-08-01'
group by c1.title, c2.week
order by c1.title, c2.week;

일단 어느 월의 데이턴지를 넣어줘야 하니
select '%월' as month, c1.title, c2.week, count(*) as cnt from course c1으로 select문을 바꿔줌
!!'A' as B는 B라는 필드 내에 A라는 내용으로 가득 채운다는 뜻

그럼 그 사이에 union all만 적어주면 됨. 근데, union all을 하면 정렬이 전부 깨짐. 이 내용은 다음 주차에 설명
# 합치기
(
	select '7월' as month, c1.title, c2.week, count(*) as cnt from courses c1
	inner join checkins c2 on c1.course_id = c2.course_id
	inner join orders o on c2.user_id = o.user_id
	where o.created_at < '2020-08-01'
	group by c1.title, c2.week
)
union all
(
	select '8월' as month, c1.title, c2.week, count(*) as cnt from courses c1
	inner join checkins c2 on c1.course_id = c2.course_id
	inner join orders o on c2.user_id = o.user_id
	where o.created_at >= '2020-08-01'
	group by c1.title, c2.week
)



