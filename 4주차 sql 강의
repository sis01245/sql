!!! Subquery : 쿼리 안에 들어있는 다른 쿼리

## 카카오페이로 결제한 유저들의 정보 보기
# user_id, name, email만 보고 싶을 때 방법 1.
select u.user_id, u.name, u.email from users u
inner join orders o
on u.user_id = o.user_id
where o.payment_method = 'kakaopay'

# 방법 2.
select user_id, name, email from users
where user_id in (
	select user_id from orders
	where payment_method = 'kakaopay'
)
방법 2처럼 where절에 쿼리가 들어있어서 join 없이도 카카오페이로 결제한 유저들의 정보를 불러올 수 있었음

- where 절 서브쿼리
where 필드명 in (서브쿼리) : 서브쿼리에서 나온 데이터와 같은 값을 가진 필드의 데이터들만 사용하겠다는 뜻

- select절 서브쿼리
select 필드명1, 필드명2, (서브쿼리) from ~~ : 
## 오늘의 다짐 좋아요 수가 평소에 받았던 좋아요 수에 비해 얼마나 높고 낮은지 확인하기
# user_id = '4b8a10e6'을 예시로
# 평균 먼저 구하기
select avg(likes) from checkins
where user_id = '4b8a10e6';

# 위의 쿼리를 select 안의 서브쿼리로 넣고, user_id = ~~ 부분은 user_id = c.user_id로 둬서 매 행의 데이터를 불러올 때마다 평균값을 계산하도록 함
select c.checkin_id,
       c.user_id, 
       c.likes, 
       (
       select avg(likes) from checkins
       where user_id = c.user_id 
       ) as avg_like_user
  from checkins c
  
- from 절 서브쿼리(가장 많이 사용됨, 가장 유용) : 내가 만든 select와 테이블을 join할 때 사용하면 좋음!

## 포인트를 많이 쌓은 사람은 좋아요도 많이 받았을까?
# 유저 별 좋아요 평균 구하기. user_id와 평균 likes가 나옴
select user_id, round(avg(likes),1) as avg_likes from checkins
group by user_id;
# 여기에 출력된 데이터를 다른 테이블 데이터에 붙이면 됨
select pu.user_id,
       pu.point
       from point_users pu
# 이거는 user_id와 포인트가 나옴. 두개를 붙이자

select pu.user_id,
       pu.point,
       ul.avg_likes # 2. 새로 붙인 테이블의 필드를 출력 필드로 불러옴
       from point_users pu
inner join (
	select user_id, round(avg(likes),1) as avg_likes from checkins
	group by user_id 
) ul # 1. 먼저 inner join으로 아까 만든 두 테이블을 user_id 기준 통합하고
on pu.user_id = ul.user_id
# 그럼 user_id, point, 평균 likes 필드의 데이터 출력 완료!

!! join 한 테이블의 모든 것을 보고 싶으면 select문에 테이블명.* 필드를 하나 추가해주면 됨

!!!!! alias를 서브쿼리에서 만든 후, 해당 alias를 필드명으로 불러와서 계산에 사용하는 것은 가능하지만, alias를 지정한 쿼리에서 바로 alias를 사용하여 계산에 사용하는 건 인식을 못함!!!
## 어느 course의 수강생들이 checkins를 더 활발하게 하는지 알아보기
select * from checkins;
# course_id별 한 번이라도 checkins를 한 유저의 수
select course_id, count(distinct(user_id)) as cnt_checkins from checkins
group by course_id;
# course 별 수강 인원 수
select course_id, count(user_id) as cnt_total from orders
group by course_id;

# 두 개를 합치기
select cp.course_title as title, count(distinct(c.user_id)) as cnt_checkins, cp.cnt_total, (count(distinct(c.user_id))/cp.cnt_total) as ratio
from checkins c
inner join (
	select *, count(user_id) as cnt_total from orders
	group by course_id
) cp
on c.course_id = cp.course_id
group by c.course_id

# 
select c.title, a.cnt_checkins, b.cnt_total,
       a.cnt_checkins/b.cnt_total as ratio
from (
	select course_id, count(distinct(user_id)) as cnt_checkins from checkins
	group by course_id
) a
inner join (
	select course_id, count(*) as cnt_total from orders
	group by course_id
) b 
on a.course_id = b.course_id
inner join courses c
on a.course_id = c.course_id


!!! With절 : subquery를 아주 간편하게 사용하게 해 줌. subquery로 사용할 애들을 맨 처음 줄에 따로 표시
with 지정테이블명1 as (서브쿼리1), 지정테이블명2 as (서브쿼리2)

# 위에 쓴 걸 아래처럼 바꿀 수 있다

with a as (
	select course_id, count(distinct(user_id)) as cnt_checkins from checkins
	group by course_id
), b as (
	select course_id, count(*) as cnt_total from orders
	group by course_id
)
select c.title, a.cnt_checkins, b.cnt_total,
       a.cnt_checkins/b.cnt_total as ratio from a
inner join b
on a.course_id = b.course_id
inner join courses c
on a.course_id = c.course_id


!!! 실무 데이터 가공(문자열 사용)
실제 업무에서는 문자열 데이터를 원하는 형태로 정리해야 하는 경우가 많음
## 이메일 주소에서 @ 앞의 아이디만 가져오거나 @ 뒤의 도메인만 가져오고 싶을 때
## substring_index 사용
select user_id, email, substring_index(email, '@', -1) from users

substring_index(email, '@', 1) 로 하는 경우엔 @ 이전 데이터를 불러오고, (email, '@', -1)로 하면 @ 이후 데이터를 가져옴

## orders 테이블에서 created_at을 날짜까지만 출력하게 하기
select user_id, created_at, substring(created_at, 1, 10) from orders

substring(필드명, 시작 포인트, 몇 글자)는 데이터의 시작 포인트에서부터 몇 글자의 데이터를 불러옴

!!! case then : case when 조건문 then 참일 때 값 else 거짓일 때 값 end 로 조건문 설정
### case
## 경우에 따라 원하는 값을 새 필드에 출력하기
## 포인트 보유액에 따라 격려 메세지를 다르게 출력하도록 하기
select user_id, point,
       (case when point > 10000 then '잘 하고 있어요'
       else '조금만 더 화이팅!' end) msg
from point_users pu

## 포인트 보유액에 따라 다른 그룹으로 묶어서 몇 명씩 있는지 확인하기
with a as (
	select pu.user_id, pu.point,
	       (case when pu.point > 10000 then '1만 이상'
	       	     when pu.point > 5000 then '5천 이상'
	             else '5천 미만' end) as lv
	from point_users pu
)
select a.lv, count(*) as cnt from a
group by a.lv

